<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Cleric Mobile v5 (Scaling & Dodge Fix)</title>
    <style>
        /* CORE RESET & MOBILE BASICS */
        body { margin: 0; padding: 0; background-color: #050505; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; background: #111; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }

        /* LANDSCAPE ENFORCEMENT */
        #rotate-message { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 999; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        
        @media screen and (orientation: portrait) {
            #rotate-message { display: flex;
                /* Adjust font size for small phones */
                font-size: 0.8em; 
            }
        }

        /* UI OVERLAYS */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* TOP BAR (Resources) */
        .top-bar { position: absolute; top: 0; left: 0; width: 100%; height: 40px; background: linear-gradient(180deg, rgba(0,0,0,0.8), rgba(0,0,0,0)); display: flex; justify-content: space-between; align-items: center; padding: 0 10px; box-sizing: border-box; z-index: 10; }
        .res-cluster { display: flex; flex-direction: column; width: 35%; }
        .bar-bg { width: 100%; height: 6px; background: #333; margin-bottom: 2px; border-radius: 3px; overflow: hidden; border: 1px solid #444; }
        .bar-fill { height: 100%; transition: width 0.1s; }
        #hp-bar .bar-fill { background: #ff4444; }
        #ap-bar .bar-fill { background: #ffd700; }
        #stam-bar .bar-fill { background: #4caf50; }
        #div-bar .bar-fill { background: #00bfff; }
        .res-label { font-size: 8px; font-weight: bold; text-shadow: 1px 1px 1px black; margin-bottom: 1px; }
        .score-box { text-align: center; font-size: 14px; color: gold; font-weight: bold; text-shadow: 0 2px 4px black; }
        
        /* JOYSTICKS */
        .joystick-zone { position: absolute; width: 120px; height: 120px; pointer-events: auto; z-index: 20; }
        #stick-left-zone { left: 20px; bottom: 20px; }
        #stick-right-zone { right: 20px; bottom: 40px; pointer-events: none; }
        
        .joystick-base { width: 90px; height: 90px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; justify-content: center; align-items: center; }
        .joystick-stick { width: 40px; height: 40px; background: rgba(255, 255, 255, 0.3); border-radius: 50%; position: absolute; box-shadow: 0 0 10px rgba(0,0,0,0.5); backdrop-filter: blur(2px); }

        /* BUTTONS */
        #skill-cluster { position: absolute; bottom: 10px; right: 10px; width: 220px; height: 220px; pointer-events: none; }
        .btn { pointer-events: auto; position: absolute; border-radius: 50%; background: #222; border: 2px solid #555; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 10px; touch-action: manipulation; box-shadow: 0 4px 6px rgba(0,0,0,0.4); transition: transform 0.1s; }
        .btn:active { transform: scale(0.9) !important; border-color: white; background: #444; }
        .btn-cd-overlay { position: absolute; top:0; left:0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); border-radius: 50%; display: flex; justify-content: center; align-items: center; color: #ff4444; font-size: 10px; }
        
        .btn-main { width: 50px; height: 50px; }
        .btn-sub { width: 45px; height: 45px; }
        .btn-mini { width: 35px; height: 35px; }
        
        #btn-dodge { width: 55px; height: 55px; bottom: 20px; right: 20px; background: #333; border-color: #999; z-index: 25; font-size: 9px; }
        #btn-lmb { bottom: 85px; right: 15px; background: #1a3a1a; color: #39FFAC; } 
        #btn-rmb { bottom: 20px; right: 85px; background: #3a3a1a; color: #ffd700; } 
        #btn-q { bottom: 140px; right: 10px; background: #2d1515; color: #ff8888; }
        #btn-e { bottom: 115px; right: 70px; background: #2d1515; color: #ff8888; }
        #btn-r { bottom: 70px; right: 115px; background: #2d1515; color: #ff8888; }
        #btn-tab { bottom: 135px; right: 140px; background: #001a33; color: #00bfff; } 
        #btn-daily { width: 50px; height: 50px; top: 60px; left: 10px; background: #333300; border: 2px solid gold; color: gold; position: absolute; pointer-events: auto; z-index: 50; box-shadow: 0 0 15px rgba(255, 215, 0, 0.2); }
        
        /* MENUS */
        #menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; backdrop-filter: blur(5px); }
        .menu-btn { padding: 12px 30px; background: #3498db; color: white; border: none; font-size: 18px; border-radius: 8px; margin: 10px; font-weight: bold; box-shadow: 0 4px #1b5e8a; }
        
        /* TOGGLE */
        .toggle-container { position: absolute; top: 60px; right: 10px; pointer-events: auto; }
        .toggle-btn { background: #222; color: #888; border: 1px solid #444; padding: 4px 8px; font-size: 10px; border-radius: 4px; text-transform: uppercase; letter-spacing: 1px; }
        .toggle-btn.active { background: #00bfff; color: white; border-color: #fff; box-shadow: 0 0 8px #00bfff; }
    </style>
</head>
<body>

<div id="rotate-message">
    <h2 style="color: #ffd700;">Please Rotate Device</h2>
    <p>This game requires Landscape mode.</p>
</div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="top-bar">
        <div class="res-cluster">
            <div class="res-label" style="color: #ff4444;">HP <span id="hp-val"></span></div>
            <div class="bar-bg" id="hp-bar"><div class="bar-fill" style="width: 100%;"></div></div>
            <div class="res-label" style="color: #4caf50;">STAM</div>
            <div class="bar-bg" id="stam-bar"><div class="bar-fill" style="width: 100%;"></div></div>
        </div>
        <div class="score-box">
            <div id="game-timer">0.0</div>
            <div id="game-score" style="font-size: 10px; color: #aaa;">0</div>
        </div>
        <div class="res-cluster" style="align-items: flex-end;">
            <div class="res-label" style="color: #00bfff;">DIVINITY</div>
            <div class="bar-bg" id="div-bar"><div class="bar-fill" style="width: 100%;"></div></div>
            <div class="res-label" style="color: #ffd700;">AP</div>
            <div class="bar-bg" id="ap-bar"><div class="bar-fill" style="width: 0%;"></div></div>
        </div>
    </div>

    <div class="ui-layer">
        <div id="btn-daily" class="btn" ontouchstart="handleTouch('1', true, event)" ontouchend="handleTouch('1', false, event)">ULT<div class="btn-cd-overlay" id="cd-daily" style="display:none;"></div></div>
        
        <div class="toggle-container">
            <button id="toggle-autofire" class="toggle-btn" onclick="toggleAutoFire()">Auto-Fire: OFF</button>
        </div>

        <div id="stick-left-zone" class="joystick-zone"><div class="joystick-base"><div class="joystick-stick" id="stick-left"></div></div></div>
        <div id="stick-right-zone" class="joystick-zone"><div class="joystick-base" style="opacity: 0.3"><div class="joystick-stick" id="stick-right"></div></div></div>

        <div id="skill-cluster">
            <div id="btn-dodge" class="btn" ontouchstart="handleTouch('shift', true, event)" ontouchend="handleTouch('shift', false, event)">DASH</div>
            <div id="btn-lmb" class="btn btn-main" ontouchstart="handleTouch('lmb', true, event)" ontouchend="handleTouch('lmb', false, event)">üî•</div>
            <div id="btn-rmb" class="btn btn-main" ontouchstart="handleTouch('rmb', true, event)" ontouchend="handleTouch('rmb', false, event)">üî¶</div>
            <div id="btn-q" class="btn btn-sub" ontouchstart="handleTouch('q', true, event)" ontouchend="handleTouch('q', false, event)">‚ö°<div class="btn-cd-overlay" id="cd-q" style="display:none;"></div></div>
            <div id="btn-e" class="btn btn-sub" ontouchstart="handleTouch('e', true, event)" ontouchend="handleTouch('e', false, event)">üí•<div class="btn-cd-overlay" id="cd-e" style="display:none;"></div></div>
            <div id="btn-r" class="btn btn-sub" ontouchstart="handleTouch('r', true, event)" ontouchend="handleTouch('r', false, event)">‚ûï<div class="btn-cd-overlay" id="cd-r" style="display:none;"></div></div>
            <div id="btn-tab" class="btn btn-mini" ontouchstart="handleTouch('tab', true, event)" ontouchend="handleTouch('tab', false, event)">‚öñÔ∏è</div>
        </div>
    </div>

    <div id="menu-overlay">
        <h1 id="menu-title" style="color: #ffd700; font-size: 28px; margin-bottom: 10px; text-shadow: 0 0 10px orange;">CLERIC MOBILE</h1>
        <p id="menu-msg" style="color: #ddd; margin-bottom: 20px; font-size: 14px;">Survive for 2 Minutes.</p>
        <button class="menu-btn" ontouchstart="startGame(event)" onclick="startGame(event)">START</button> 
        <div style="margin-top:20px; font-size: 11px; color: #666; text-align: center; line-height: 1.6;">
            Left Stick: Move<br>Right Area: Aim<br>
            Use Landscape Mode!
        </div>
    </div>
</div>

<script>
/* ================================
   LOGIC: VIRTUAL RESOLUTION
   ================================ */
const WORLD_W = 1200;
const WORLD_H = 1200;
const GAME_CENTER_X = WORLD_W / 2;
const GAME_CENTER_Y = WORLD_H / 2;
const NODE_RADIUS = 350; 
const GRID_SIZE = 100;
const FPS = 60;
const GAME_END_FRAME = 120 * FPS; 

// Stats
const PLAYER_SPEED = 7; 
const MAX_HP = 2000;
const MAX_STAMINA = 100;
const MAX_DIVINITY = 1000;
const MAX_AP = 1000;
const STAMINA_REGEN = 0.5;
const DIVINITY_REGEN_PASSIVE = 2;
const DIVINITY_REGEN_CHANNEL = 25;

const SKILL_STATS = {
    SACRED_FLAME: { frames: 5, damage: 180, speed: 18, color: '#39FFAC', ap: 5 },
    LANCE_OF_FAITH: { tick: 10, damage: 110, range: 600, ap: 10, slow: 0.75 },
    DAUNTING_LIGHT: { cast: 33, damage: 1600, radius: 110, cd: 120, div: 200, ap: 30 },
    SUNBURST: { cast: 60, damage: 400, heal: 200, radius: 250, knock: 350, cd: 240 },
    BASTION: { cast: 30, heal: 1000, radius: 180, cd: 240, div: 300 },
    DAILY: { cast: 90, damage: 2800, radius: 200, stun: 120, cd: 100, hot: 100, hotDur: 600 },
    CHANNEL: { regen: 25 }
};

/* ================================
   ENGINE & INPUTS
   ================================ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let scaleFactor = 1;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // FIX: Calculate scale factor based on keeping WORLD_W visible across the viewport.
    const targetAspect = 16 / 9; // Common desktop aspect ratio (1.77)
    const currentAspect = canvas.width / canvas.height;

    // Use a fixed virtual width for scaling reference
    const VIRTUAL_WIDTH = 1000; 

    if (currentAspect < targetAspect) {
        // Narrower than desktop (taller viewport for the width, common on phones)
        scaleFactor = canvas.width / VIRTUAL_WIDTH; 
    } else {
        // Wider than desktop (like a tablet or desktop browser resized)
        scaleFactor = canvas.height / (VIRTUAL_WIDTH / targetAspect);
    }
    // Ensure minimum scale for small devices
    scaleFactor = Math.max(0.6, scaleFactor);
}
window.addEventListener('resize', resize);
resize();

const joyLeft = { x: 0, y: 0, active: false, id: null, originX: 0, originY: 0 };
const joyRight = { x: 0, y: 0, active: false, id: null, originX: 0, originY: 0 };
const keys = { lmb: false, rmb: false, shift: false, q: false, e: false, r: false, tab: false, '1': false };
let autoFire = false;
// Initialize vMouse in World Coordinates so it's ready for dodge logic
let vMouse = { x: GAME_CENTER_X, y: GAME_CENTER_Y - 200 }; 

function toggleAutoFire() {
    autoFire = !autoFire;
    const btn = document.getElementById('toggle-autofire');
    btn.innerText = `Auto-Fire: ${autoFire ? 'ON' : 'OFF'}`;
    btn.classList.toggle('active', autoFire);
}

function handleTouch(key, state, event) { 
    if (event) event.preventDefault(); 
    keys[key] = state; 
}

// Touch Logic (Passive:false allows preventDefault)
document.addEventListener('touchstart', e => {
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        
        // Left Stick (bottom half, left side)
        if (t.clientX < window.innerWidth / 2 && t.clientY > window.innerHeight / 2) {
            if (!joyLeft.active) {
                joyLeft.id = t.identifier; joyLeft.active = true;
                joyLeft.originX = t.clientX; joyLeft.originY = t.clientY;
                updateJoyVisual('left', 0, 0);
            }
        // Right Stick Area (right side, excluding buttons which have their own handlers)
        } else if (t.clientX > window.innerWidth / 2 && t.clientY < window.innerHeight / 2) {
            if (!joyRight.active) {
                joyRight.id = t.identifier; joyRight.active = true;
                joyRight.originX = t.clientX; joyRight.originY = t.clientY;
                updateJoyVisual('right', 0, 0);
            }
        }
    }
}, {passive: false});

document.addEventListener('touchmove', e => {
    e.preventDefault(); 
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === joyLeft.id) {
            const dx = t.clientX - joyLeft.originX; const dy = t.clientY - joyLeft.originY;
            const dist = Math.min(45, Math.sqrt(dx*dx + dy*dy));
            const angle = Math.atan2(dy, dx);
            joyLeft.x = Math.cos(angle) * (dist / 45); joyLeft.y = Math.sin(angle) * (dist / 45);
            updateJoyVisual('left', Math.cos(angle)*dist, Math.sin(angle)*dist);
        }
        if (t.identifier === joyRight.id) {
            const dx = t.clientX - joyRight.originX; const dy = t.clientY - joyRight.originY;
            const dist = Math.min(45, Math.sqrt(dx*dx + dy*dy));
            const angle = Math.atan2(dy, dx);
            joyRight.x = Math.cos(angle) * (dist / 45); joyRight.y = Math.sin(angle) * (dist / 45);
            
            if (dist > 5 && player) {
                // Aim logic: Convert joystick direction into world coordinates
                const aimReach = 450; 
                let centerOffsetX = GAME_CENTER_X - canvas.width / (2 * scaleFactor);
                let centerOffsetY = GAME_CENTER_Y - canvas.height / (2 * scaleFactor);
                
                // If player is moving stick, use that for aiming
                if (Math.abs(joyRight.x) > 0.1 || Math.abs(joyRight.y) > 0.1) {
                    const dir = new Vector(joyRight.x, joyRight.y).normalize();
                    vMouse.x = player.pos.x + dir.x * aimReach;
                    vMouse.y = player.pos.y + dir.y * aimReach;
                }
            }
            updateJoyVisual('right', Math.cos(angle)*dist, Math.sin(angle)*dist);
        }
    }
}, {passive: false});

document.addEventListener('touchend', e => {
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === joyLeft.id) { 
            joyLeft.active = false; joyLeft.x = 0; joyLeft.y = 0; updateJoyVisual('left', 0, 0); 
        }
        if (t.identifier === joyRight.id) { 
            joyRight.active = false; joyRight.x = 0; joyRight.y = 0; updateJoyVisual('right', 0, 0); 
        }
    }
});

function updateJoyVisual(side, x, y) {
    const el = document.getElementById(`stick-${side}`);
    if(el) el.style.transform = `translate(${x}px, ${y}px)`;
}

/* ================================
   GAME CLASSES
   ================================ */
class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x*this.x + this.y*this.y); }
    normalize() { const m = this.mag(); return m === 0 ? new Vector(0,0) : new Vector(this.x/m, this.y/m); }
}

class Entity {
    constructor(x, y, r, c) { this.pos = new Vector(x,y); this.r = r; this.c = c; this.dead = false; }
    draw(ctx) { ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.r, 0, Math.PI*2); ctx.fillStyle = this.c; ctx.fill(); }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, 20, type==='MELEE'?'#f40':(type==='RANGED'?'#36f':'#0c0'));
        this.type = type;
        this.maxHp = type==='MELEE'?8000:(type==='RANGED'?3000:5000);
        this.hp = this.maxHp;
        this.speed = type==='MELEE'?2.5:(type==='RANGED'?4.5:3.5);
        this.stun = 0;
    }
}

class Player extends Entity {
    constructor() {
        super(GAME_CENTER_X, GAME_CENTER_Y, 20, '#00bfff');
        this.hp = MAX_HP; this.stamina = MAX_STAMINA; this.divinity = MAX_DIVINITY; this.ap = 0;
        this.cooldowns = { q:0, e:0, r:0, daily:0 };
        this.maxCd = { q: SKILL_STATS.DAUNTING_LIGHT.cd, e: SKILL_STATS.SUNBURST.cd, r: SKILL_STATS.BASTION.cd, daily: SKILL_STATS.DAILY.cd };
        this.isDodging = false; this.dodgeTimer = 0;
        this.isCasting = false; this.castTimer = 0; this.castCb = null;
        this.slowTimer = 0; this.poisonTimer = 0; this.hotTimer = 0;
        this.exhausted = false;
        this.dodgeDir = new Vector(0, -1); // Initialize dodge direction safely
    }
    update() {
        if (!this.isDodging) this.stamina = Math.min(MAX_STAMINA, this.stamina + STAMINA_REGEN);
        if (keys.tab) this.divinity = Math.min(MAX_DIVINITY, this.divinity + DIVINITY_REGEN_CHANNEL);
        else this.divinity = Math.min(MAX_DIVINITY, this.divinity + DIVINITY_REGEN_PASSIVE);

        if (this.slowTimer > 0) this.slowTimer--;
        if (this.poisonTimer > 0) {
            if (this.poisonTimer % 60 === 0) { this.hp -= 50; showFloat("Poison!", this.pos, '#8f0'); }
            this.poisonTimer--;
        }
        if (this.hotTimer > 0) {
            if (this.hotTimer % 60 === 0) { this.hp = Math.min(MAX_HP, this.hp + SKILL_STATS.DAILY.hot); showFloat("+100", this.pos, '#0f0'); }
            this.hotTimer--;
        }

        if (this.stamina <= 0 && !this.exhausted) { this.exhausted = true; showFloat("TIRED", this.pos, 'red'); }
        if (this.exhausted && this.stamina > 90) this.exhausted = false;

        for(let k in this.cooldowns) if(this.cooldowns[k]>0) this.cooldowns[k]--;

        if (this.isCasting) {
            this.castTimer--;
            if (this.castTimer <= 0) { if (this.castCb) this.castCb(); this.isCasting = false; }
            return; 
        }

        let speed = PLAYER_SPEED;
        if (this.exhausted || this.slowTimer > 0) speed *= 0.5;
        if (keys.rmb) speed *= SKILL_STATS.LANCE_OF_FAITH.slow;

        if (this.isDodging) {
            this.dodgeTimer--;
            if(this.dodgeTimer<=0) this.isDodging = false;
            // FIX: Ensure dodgeDir is valid before using it
            if (this.dodgeDir && this.dodgeDir.mag() > 0) {
                this.pos = this.pos.add(this.dodgeDir.mult(14)); 
            } else {
                 this.isDodging = false; // Stop dodge if direction is invalid
            }
        } else if (!keys.tab) {
            if (Math.abs(joyLeft.x) > 0.1 || Math.abs(joyLeft.y) > 0.1) {
                this.pos.x += joyLeft.x * speed;
                this.pos.y += joyLeft.y * speed;
            }
        }

        this.pos.x = Math.max(20, Math.min(WORLD_W-20, this.pos.x));
        this.pos.y = Math.max(20, Math.min(WORLD_H-20, this.pos.y));
    }

    dodge() {
        if (this.stamina < 20 || this.isDodging || keys.tab || this.exhausted) return;
        if (this.isCasting) { this.isCasting = false; showFloat("Canceled", this.pos, '#fff'); }
        this.stamina -= 20;
        this.isDodging = true;
        this.dodgeTimer = 12;
        
        if (Math.abs(joyLeft.x) > 0.1 || Math.abs(joyLeft.y) > 0.1) {
            // Dodge in movement direction
            this.dodgeDir = new Vector(joyLeft.x, joyLeft.y).normalize();
        } else {
            // Dodge away from the aim point (backward dodge)
            let aimDir = vMouse.sub(this.pos);
            
            // FIX: Handle case where aimDir is zero vector (i.e., vMouse is exactly at player.pos)
            if (aimDir.mag() < 1) {
                // If not moving and not aiming, use last direction or a safe default (e.g., straight down)
                this.dodgeDir = this.dodgeDir.mult(-1).normalize(); 
            } else {
                this.dodgeDir = aimDir.normalize().mult(-1);
            }
        }
    }
}

/* ================================
   GLOBALS & LOGIC
   ================================ */
let player;
let enemies = [];
let projectiles = [];
let splats = [];
let floats = [];
let frame = 0;
let gameActive = false;
let score = 0;
let kills = 0;

function startGame(e) {
    if (e) e.preventDefault(); 
    document.getElementById('menu-overlay').style.display = 'none';
    player = new Player();
    vMouse = { x: player.pos.x, y: player.pos.y - 300 }; // Re-initialize vMouse safely
    enemies = [];
    projectiles = [];
    splats = [];
    floats = [];
    frame = 0;
    score = 0;
    kills = 0;
    gameActive = true;
    resize();
    loop();
}

function spawnMob() {
    let type = Math.random() < 0.6 ? 'MELEE' : (Math.random() < 0.5 ? 'RANGED' : 'HEALER');
    let x, y, d;
    do {
        x = Math.random() * WORLD_W;
        y = Math.random() * WORLD_H;
        d = new Vector(x,y).sub(new Vector(GAME_CENTER_X, GAME_CENTER_Y)).mag();
    } while(d < NODE_RADIUS + 50);
    
    enemies.push(new Enemy(x, y, type));
}

function showFloat(txt, pos, col) {
    floats.push({txt:txt, pos:new Vector(pos.x, pos.y), col:col, life:60});
}

function castSkills() {
    if (player.isCasting || player.isDodging || keys.tab) return;
    if (keys.shift) player.dodge();

    if ((keys.lmb || (autoFire && joyRight.active)) && frame % SKILL_STATS.SACRED_FLAME.frames === 0) {
        let dir = vMouse.sub(player.pos);
        projectiles.push({
            pos: new Vector(player.pos.x, player.pos.y),
            vel: dir.normalize().mult(SKILL_STATS.SACRED_FLAME.speed),
            dmg: SKILL_STATS.SACRED_FLAME.damage, owner: 'player', life: 60, r: 8, col: SKILL_STATS.SACRED_FLAME.color
        });
        player.ap = Math.min(MAX_AP, player.ap + 5);
    }

    if (keys.rmb && frame % SKILL_STATS.LANCE_OF_FAITH.tick === 0) {
        let aimDir = vMouse.sub(player.pos);
        let hit = false;
        enemies.forEach(e => {
            let toE = e.pos.sub(player.pos);
            let angle = Math.abs(Math.atan2(aimDir.y, aimDir.x) - Math.atan2(toE.y, toE.x));
            if (toE.mag() < SKILL_STATS.LANCE_OF_FAITH.range && angle < 0.35) {
                e.hp -= SKILL_STATS.LANCE_OF_FAITH.damage;
                showFloat(SKILL_STATS.LANCE_OF_FAITH.damage, e.pos, '#ff0');
                if(e.hp<=0) kill(e);
                hit = true;
            }
        });
        if(hit) player.ap = Math.min(MAX_AP, player.ap + 10);
    }

    if (keys.q && player.cooldowns.q <= 0 && player.divinity >= SKILL_STATS.DAUNTING_LIGHT.div) {
        player.divinity -= SKILL_STATS.DAUNTING_LIGHT.div;
        player.cooldowns.q = player.maxCd.q;
        player.isCasting = true;
        player.castTimer = SKILL_STATS.DAUNTING_LIGHT.cast;
        let tPos = new Vector(vMouse.x, vMouse.y);
        player.castCb = () => {
            splats.push({pos:tPos, r:SKILL_STATS.DAUNTING_LIGHT.radius, col:'gold', life:15});
            enemies.forEach(e => {
                if(e.pos.sub(tPos).mag() < SKILL_STATS.DAUNTING_LIGHT.radius) {
                    e.hp -= SKILL_STATS.DAUNTING_LIGHT.damage;
                    showFloat(SKILL_STATS.DAUNTING_LIGHT.damage+"!", e.pos, '#ff0');
                    if(e.hp<=0) kill(e);
                    player.ap = Math.min(MAX_AP, player.ap + 30);
                }
            });
        };
    }

    if (keys.e && player.cooldowns.e <= 0) {
        player.cooldowns.e = player.maxCd.e;
        player.hp = Math.min(MAX_HP, player.hp + SKILL_STATS.SUNBURST.heal);
        splats.push({pos:player.pos, r:SKILL_STATS.SUNBURST.radius, col:'orange', life:10});
        enemies.forEach(e => {
            let dist = e.pos.sub(player.pos);
            if(dist.mag() < SKILL_STATS.SUNBURST.radius) {
                e.hp -= SKILL_STATS.SUNBURST.damage;
                e.pos = e.pos.add(dist.normalize().mult(SKILL_STATS.SUNBURST.knock));
                if(e.hp<=0) kill(e);
            }
        });
    }

    if (keys.r && player.cooldowns.r <= 0 && player.divinity >= SKILL_STATS.BASTION.div) {
        player.divinity -= SKILL_STATS.BASTION.div;
        player.cooldowns.r = player.maxCd.r;
        player.isCasting = true;
        player.castTimer = SKILL_STATS.BASTION.cast;
        let tPos = new Vector(vMouse.x, vMouse.y);
        player.castCb = () => {
            splats.push({pos:tPos, r:SKILL_STATS.BASTION.radius, col:'#0f0', life:10});
            if(player.pos.sub(tPos).mag() < SKILL_STATS.BASTION.radius) {
                player.hp = Math.min(MAX_HP, player.hp + SKILL_STATS.BASTION.heal);
                showFloat("+" + SKILL_STATS.BASTION.heal, player.pos, '#0f0');
            }
        };
    }
    
    if (keys['1'] && player.cooldowns.daily <= 0 && player.ap >= MAX_AP) {
        player.ap = 0;
        player.cooldowns.daily = player.maxCd.daily;
        player.hotTimer = SKILL_STATS.DAILY.hotDur;
        let tPos = new Vector(vMouse.x, vMouse.y);
        splats.push({pos:tPos, r:SKILL_STATS.DAILY.radius, col:'white', life:90}); 
        setTimeout(() => {
             enemies.forEach(e => {
                if(e.pos.sub(tPos).mag() < SKILL_STATS.DAILY.radius) {
                    e.hp -= SKILL_STATS.DAILY.damage;
                    e.stun = SKILL_STATS.DAILY.stun;
                    if(e.hp<=0) kill(e);
                }
            });
        }, 1000); 
    }
}

function kill(e) {
    if(e.dead) return;
    e.dead = true;
    kills++;
    player.ap = Math.min(MAX_AP, player.ap + 50);
}

function loop() {
    if(!gameActive) return;
    frame++;
    
    if (frame % 240 === 0 && enemies.length < 8) spawnMob();

    player.update();
    castSkills();

    enemies.forEach(e => {
        if(e.dead) return;
        if(e.stun && e.stun > 0) { e.stun--; return; }
        
        let toP = player.pos.sub(e.pos);
        if (toP.mag() > 30) e.pos = e.pos.add(toP.normalize().mult(e.speed));
        
        if (toP.mag() < 40 && frame % 60 === 0) {
            player.hp -= 50;
            showFloat("-50", player.pos, 'red');
        }
        if (e.type !== 'MELEE' && frame % 120 === 0 && toP.mag() < 500) {
            projectiles.push({
                pos: new Vector(e.pos.x, e.pos.y),
                vel: toP.normalize().mult(6),
                dmg: 100, owner: 'enemy', life: 100, r: 6, col: '#f0f'
            });
        }
    });

    projectiles.forEach(p => {
        p.pos = p.pos.add(p.vel);
        p.life--;
        if(p.owner === 'player') {
            enemies.forEach(e => {
                if(!e.dead && e.pos.sub(p.pos).mag() < e.r + p.r) {
                    e.hp -= p.dmg;
                    p.life = 0;
                    showFloat(p.dmg, e.pos, '#ff0');
                    if(e.hp<=0) kill(e);
                }
            });
        } else {
            // Check collision only if player is not dodging
            if(!player.isDodging && player.pos.sub(p.pos).mag() < 20 + p.r) {
                player.hp -= p.dmg;
                p.life = 0;
                showFloat("-"+p.dmg, player.pos, 'red');
            }
        }
    });

    projectiles = projectiles.filter(p => p.life > 0);
    enemies = enemies.filter(e => !e.dead);
    splats = splats.filter(s => s.life-- > 0);
    floats = floats.filter(f => { f.pos.y -= 1; return f.life-- > 0; });

    let onNode = player.pos.sub(new Vector(GAME_CENTER_X, GAME_CENTER_Y)).mag() < NODE_RADIUS;
    if (onNode) score += 1; 
    
    if (player.hp <= 0) gameOver("DIED");
    if (frame >= GAME_END_FRAME) gameOver("VICTORY");

    draw();
    updateUI();
    requestAnimationFrame(loop);
}

function gameOver(msg) {
    gameActive = false;
    document.getElementById('menu-overlay').style.display = 'flex';
    document.getElementById('menu-title').innerText = msg;
    document.getElementById('menu-msg').innerText = `Score: ${score} | Kills: ${kills}`;
}

function updateUI() {
    document.getElementById('hp-bar').querySelector('div').style.width = (player.hp/MAX_HP*100)+'%';
    document.getElementById('hp-val').innerText = Math.ceil(player.hp);
    document.getElementById('ap-bar').querySelector('div').style.width = (player.ap/MAX_AP*100)+'%';
    document.getElementById('stam-bar').querySelector('div').style.width = (player.stamina/MAX_STAMINA*100)+'%';
    document.getElementById('div-bar').querySelector('div').style.width = (player.divinity/MAX_DIVINITY*100)+'%';
    document.getElementById('game-timer').innerText = (frame/60).toFixed(1);
    document.getElementById('game-score').innerText = score;
    
    const setCD = (id, cur, max) => {
        const el = document.getElementById(id);
        if(cur > 0) { el.style.display = 'flex'; el.innerText = (cur/60).toFixed(1); }
        else { el.style.display = 'none'; }
    };
    setCD('cd-q', player.cooldowns.q, player.maxCd.q);
    setCD('cd-e', player.cooldowns.e, player.maxCd.e);
    setCD('cd-r', player.cooldowns.r, player.maxCd.r);
    setCD('cd-daily', player.cooldowns.daily, player.maxCd.daily);
    
    document.getElementById('btn-tab').style.borderColor = keys.tab ? 'white' : '#555';
}

function draw() {
    ctx.fillStyle = '#111'; ctx.fillRect(0,0,canvas.width, canvas.height);
    
    ctx.save();
    // Center the world view on the canvas
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.scale(scaleFactor, scaleFactor);
    ctx.translate(-GAME_CENTER_X, -GAME_CENTER_Y);

    // World Grid
    ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
    for(let x=0; x<=WORLD_W; x+=GRID_SIZE) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x, WORLD_H); ctx.stroke(); }
    for(let y=0; y<=WORLD_H; y+=GRID_SIZE) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WORLD_W, y); ctx.stroke(); }
    ctx.strokeStyle = '#500'; ctx.lineWidth = 5; ctx.strokeRect(0,0,WORLD_W, WORLD_H);

    // Node
    ctx.beginPath();
    ctx.arc(GAME_CENTER_X, GAME_CENTER_Y, NODE_RADIUS, 0, Math.PI*2);
    ctx.strokeStyle = '#333'; ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle = 'rgba(0,255,100,0.05)'; ctx.fill();

    splats.forEach(s => {
        ctx.beginPath(); ctx.arc(s.pos.x, s.pos.y, s.r, 0, Math.PI*2);
        ctx.fillStyle = s.col; ctx.globalAlpha = 0.4; ctx.fill(); ctx.globalAlpha = 1;
    });

    enemies.forEach(e => {
        e.draw(ctx);
        ctx.fillStyle = 'red'; ctx.fillRect(e.pos.x-15, e.pos.y-30, 30*(e.hp/e.maxHp), 4);
    });

    player.draw(ctx);
    if(keys.tab) {
        ctx.strokeStyle = '#00bfff'; ctx.beginPath(); ctx.arc(player.pos.x, player.pos.y, 30, 0, Math.PI*2); ctx.stroke();
    }
    
    projectiles.forEach(p => {
        ctx.beginPath(); ctx.arc(p.pos.x, p.pos.y, p.r, 0, Math.PI*2);
        ctx.fillStyle = p.col; ctx.fill();
    });

    if(joyRight.active || keys.q || keys.r || keys.lmb || keys.rmb) {
        ctx.beginPath();
        ctx.arc(vMouse.x, vMouse.y, 10, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 2; ctx.stroke();
        
        ctx.beginPath(); ctx.moveTo(player.pos.x, player.pos.y); ctx.lineTo(vMouse.x, vMouse.y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 1; ctx.stroke();
    }
    
    if (keys.rmb) {
        ctx.beginPath(); ctx.moveTo(player.pos.x, player.pos.y); ctx.lineTo(vMouse.x, vMouse.y);
        ctx.strokeStyle = 'gold'; ctx.lineWidth = 4; ctx.stroke();
    }

    floats.forEach(f => {
        ctx.fillStyle = f.col; ctx.font = "bold 24px Arial"; 
        ctx.fillText(f.txt, f.pos.x - 10, f.pos.y);
    });

    ctx.restore();
}
</script>
</body>
</html>
