<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Cleric Mobile v1</title>
    <style>
        /* CORE RESET & MOBILE BASICS */
        body { margin: 0; padding: 0; background-color: #000; color: white; font-family: sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; background: #111; }
        canvas { display: block; width: 100%; height: 100%; }

        /* UI OVERLAYS */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* TOP BAR (Resources) */
        .top-bar { position: absolute; top: 0; left: 0; width: 100%; height: 50px; background: rgba(0,0,0,0.5); display: flex; justify-content: space-between; align-items: center; padding: 0 10px; box-sizing: border-box; }
        .res-cluster { display: flex; flex-direction: column; width: 30%; }
        .bar-bg { width: 100%; height: 8px; background: #333; margin-bottom: 2px; border-radius: 2px; overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.1s; }
        #hp-bar .bar-fill { background: #ff4444; }
        #ap-bar .bar-fill { background: #ffd700; }
        #stam-bar .bar-fill { background: #4caf50; }
        #div-bar .bar-fill { background: #00bfff; }
        
        .score-box { text-align: center; font-size: 12px; color: #gold; font-weight: bold; }
        
        /* JOYSTICKS */
        .joystick-zone { position: absolute; bottom: 20px; width: 120px; height: 120px; pointer-events: auto; }
        #stick-left-zone { left: 20px; bottom: 20px; }
        #stick-right-zone { right: 20px; bottom: 40px; pointer-events: none; /* Right stick is visual/logic helper, actual input covers whole right side */ }
        
        .joystick-base { width: 100px; height: 100px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; justify-content: center; align-items: center; }
        .joystick-stick { width: 40px; height: 40px; background: rgba(255, 255, 255, 0.5); border-radius: 50%; position: absolute; box-shadow: 0 0 10px rgba(0,0,0,0.5); }

        /* SKILL BUTTONS (Right Side Arc) */
        #skill-cluster { position: absolute; bottom: 20px; right: 20px; width: 250px; height: 250px; pointer-events: none; }
        .btn { pointer-events: auto; position: absolute; border-radius: 50%; background: #222; border: 2px solid #555; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 12px; touch-action: manipulation; box-shadow: 0 4px 6px rgba(0,0,0,0.4); }
        .btn:active { transform: scale(0.95); border-color: white; background: #444; }
        .btn-cd-overlay { position: absolute; top:0; left:0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); border-radius: 50%; display: flex; justify-content: center; align-items: center; color: #ff4444; font-size: 10px; }
        
        /* Layout of buttons */
        /* Center (Dodge) */
        #btn-dodge { width: 60px; height: 60px; bottom: 10px; right: 10px; background: #333; border-color: #999; z-index: 20; font-size: 10px; }
        
        /* Arc 1 */
        #btn-lmb { width: 55px; height: 55px; bottom: 80px; right: 10px; background: #204020; color: #39FFAC; } /* Sacred Flame */
        #btn-rmb { width: 55px; height: 55px; bottom: 10px; right: 80px; background: #404020; color: #ffd700; } /* Beam */
        
        /* Arc 2 */
        #btn-q { width: 50px; height: 50px; bottom: 140px; right: 10px; background: #3a2020; color: #ff8888; } /* Nuke */
        #btn-e { width: 50px; height: 50px; bottom: 110px; right: 70px; background: #3a2020; color: #ff8888; } /* Sunburst */
        #btn-r { width: 50px; height: 50px; bottom: 70px; right: 110px; background: #3a2020; color: #ff8888; } /* Heal */
        
        /* Utility */
        #btn-tab { width: 45px; height: 45px; bottom: 140px; right: 160px; background: #001a33; color: #00bfff; } /* Channel */
        #btn-daily { width: 60px; height: 60px; top: 60px; left: 10px; background: #333300; border: 2px solid gold; color: gold; position: absolute; pointer-events: auto; z-index: 50; } /* Daily (Top Left) */
        
        /* MENUS */
        #menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; }
        .menu-btn { padding: 15px 40px; background: #3498db; color: white; border: none; font-size: 20px; border-radius: 8px; margin: 10px; font-weight: bold; }
        
        /* VISUAL FEEDBACK */
        .feedback-text { position: absolute; color: white; font-weight: bold; pointer-events: none; text-shadow: 1px 1px 2px black; z-index: 50; }
        
        /* TOGGLE */
        .toggle-container { position: absolute; top: 60px; right: 10px; pointer-events: auto; }
        .toggle-btn { background: #333; color: #aaa; border: 1px solid #555; padding: 5px 10px; font-size: 12px; border-radius: 4px; }
        .toggle-btn.active { background: #00bfff; color: white; border-color: #fff; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="top-bar">
        <div class="res-cluster">
            <div style="font-size: 10px; color: #ff4444;">HP <span id="hp-val"></span></div>
            <div class="bar-bg" id="hp-bar"><div class="bar-fill" style="width: 100%;"></div></div>
            <div style="font-size: 10px; color: #4caf50;">STAM</div>
            <div class="bar-bg" id="stam-bar"><div class="bar-fill" style="width: 100%;"></div></div>
        </div>
        <div class="score-box">
            <div id="game-timer">0.0s</div>
            <div id="game-score">SCORE: 0</div>
        </div>
        <div class="res-cluster" style="align-items: flex-end;">
            <div style="font-size: 10px; color: #00bfff;">DIVINITY</div>
            <div class="bar-bg" id="div-bar"><div class="bar-fill" style="width: 100%;"></div></div>
            <div style="font-size: 10px; color: #ffd700;">AP</div>
            <div class="bar-bg" id="ap-bar"><div class="bar-fill" style="width: 0%;"></div></div>
        </div>
    </div>

    <div class="ui-layer">
        <div id="btn-daily" class="btn" ontouchstart="handleTouch('1', true)" ontouchend="handleTouch('1', false)">
            ULT
            <div class="btn-cd-overlay" id="cd-daily" style="display:none;"></div>
        </div>
        
        <div class="toggle-container">
            <button id="toggle-autofire" class="toggle-btn" onclick="toggleAutoFire()">Auto-Fire: OFF</button>
        </div>

        <div id="stick-left-zone" class="joystick-zone">
            <div class="joystick-base">
                <div class="joystick-stick" id="stick-left"></div>
            </div>
        </div>

        <div id="stick-right-zone" class="joystick-zone">
            <div class="joystick-base" style="opacity: 0.3">
                <div class="joystick-stick" id="stick-right"></div>
            </div>
        </div>

        <div id="skill-cluster">
            <div id="btn-dodge" class="btn" ontouchstart="handleTouch('shift', true)" ontouchend="handleTouch('shift', false)">DODGE</div>
            
            <div id="btn-lmb" class="btn" ontouchstart="handleTouch('lmb', true)" ontouchend="handleTouch('lmb', false)">üî•</div>
            <div id="btn-rmb" class="btn" ontouchstart="handleTouch('rmb', true)" ontouchend="handleTouch('rmb', false)">üî¶</div>
            
            <div id="btn-q" class="btn" ontouchstart="handleTouch('q', true)" ontouchend="handleTouch('q', false)">
                ‚ö°
                <div class="btn-cd-overlay" id="cd-q" style="display:none;"></div>
            </div>
            
            <div id="btn-e" class="btn" ontouchstart="handleTouch('e', true)" ontouchend="handleTouch('e', false)">
                üí•
                <div class="btn-cd-overlay" id="cd-e" style="display:none;"></div>
            </div>
            
            <div id="btn-r" class="btn" ontouchstart="handleTouch('r', true)" ontouchend="handleTouch('r', false)">
                ‚ûï
                <div class="btn-cd-overlay" id="cd-r" style="display:none;"></div>
            </div>
            
            <div id="btn-tab" class="btn" ontouchstart="handleTouch('tab', true)" ontouchend="handleTouch('tab', false)">‚öñÔ∏è</div>
        </div>
    </div>

    <div id="menu-overlay">
        <h1 id="menu-title" style="color: #ffd700; font-size: 32px; margin-bottom: 20px;">CLERIC SIM MOBILE</h1>
        <p id="menu-msg" style="color: white; margin-bottom: 20px;">Survive for 2 Minutes.</p>
        <button class="menu-btn" onclick="startGame()">START GAME</button>
        <div style="margin-top:20px; font-size: 12px; color: #888;">
            L-Stick: Move &nbsp;|&nbsp; R-Stick Area: Aim<br>
            Center buttons to Attack
        </div>
    </div>
</div>

<script>
/* ================================
   CORE CONSTANTS (Unchanged logic)
   ================================ */
const FPS = 60;
const GAME_END_FRAME = 120 * FPS; 

// Stats
const PLAYER_SPEED = 5;
const MAX_HP = 2000;
const MAX_STAMINA = 100;
const MAX_DIVINITY = 1000;
const MAX_AP = 1000;
const STAMINA_REGEN = 0.5;
const DIVINITY_REGEN_PASSIVE = 2;
const DIVINITY_REGEN_CHANNEL = 25;

// Grid/Map
let CANVAS_WIDTH = window.innerWidth;
let CANVAS_HEIGHT = window.innerHeight;
const GRID_SQUARE_SIZE = 100;
let NODE_CENTER_X = CANVAS_WIDTH / 2;
let NODE_CENTER_Y = CANVAS_HEIGHT / 2;
const NODE_RADIUS = 350; // Slightly smaller visual for mobile

// Skills
const SKILL_STATS = {
    SACRED_FLAME: { frames: 5, damage: 180, speed: 15, color: '#39FFAC', ap: 5 },
    LANCE_OF_FAITH: { tick: 10, damage: 110, range: 600, ap: 10, slow: 0.75 },
    DAUNTING_LIGHT: { cast: 33, damage: 1600, radius: 90, cd: 120, div: 200, ap: 30 },
    SUNBURST: { cast: 60, damage: 400, heal: 200, radius: 200, knock: 300, cd: 240 },
    BASTION: { cast: 30, heal: 1000, radius: 160, cd: 240, div: 300 },
    DAILY: { cast: 90, damage: 2800, radius: 150, stun: 120, cd: 100, hot: 100, hotDur: 600 },
    CHANNEL: { regen: 25 }
};

/* ================================
   ENGINE & INPUTS
   ================================ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Resizing
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    CANVAS_WIDTH = canvas.width;
    CANVAS_HEIGHT = canvas.height;
    NODE_CENTER_X = CANVAS_WIDTH / 2;
    NODE_CENTER_Y = CANVAS_HEIGHT / 2;
}
window.addEventListener('resize', resize);
resize();

// Input State
const joyLeft = { x: 0, y: 0, active: false, id: null, originX: 0, originY: 0 };
const joyRight = { x: 0, y: 0, active: false, id: null, originX: 0, originY: 0 };
const keys = { lmb: false, rmb: false, shift: false, q: false, e: false, r: false, tab: false, '1': false };
let autoFire = false;

/* ================================
   TOUCH HANDLING
   ================================ */
// Virtual Mouse for aiming calculations
let vMouse = { x: CANVAS_WIDTH/2, y: CANVAS_HEIGHT/2 };

function toggleAutoFire() {
    autoFire = !autoFire;
    const btn = document.getElementById('toggle-autofire');
    btn.innerText = `Auto-Fire: ${autoFire ? 'ON' : 'OFF'}`;
    btn.classList.toggle('active', autoFire);
}

function handleTouch(key, state) {
    // Prevent defaults handled by css touch-action, but logic here maps buttons
    keys[key] = state;
}

// Joystick Logic
document.addEventListener('touchstart', e => {
    // e.preventDefault(); // Handled by CSS
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        
        // Left Stick (Bottom Left Quadrant)
        if (t.clientX < window.innerWidth / 2 && t.clientY > window.innerHeight / 2) {
            if (!joyLeft.active) {
                joyLeft.id = t.identifier;
                joyLeft.active = true;
                joyLeft.originX = t.clientX;
                joyLeft.originY = t.clientY;
                updateJoyVisual('left', 0, 0);
            }
        }
        // Right Stick (Anywhere right side not on a button)
        else if (t.clientX > window.innerWidth / 2 && !e.target.classList.contains('btn')) {
            if (!joyRight.active) {
                joyRight.id = t.identifier;
                joyRight.active = true;
                joyRight.originX = t.clientX;
                joyRight.originY = t.clientY;
                updateJoyVisual('right', 0, 0);
            }
        }
    }
}, {passive: false});

document.addEventListener('touchmove', e => {
    // e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === joyLeft.id) {
            const dx = t.clientX - joyLeft.originX;
            const dy = t.clientY - joyLeft.originY;
            const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
            const angle = Math.atan2(dy, dx);
            joyLeft.x = Math.cos(angle) * (dist / 50);
            joyLeft.y = Math.sin(angle) * (dist / 50);
            updateJoyVisual('left', Math.cos(angle)*dist, Math.sin(angle)*dist);
        }
        if (t.identifier === joyRight.id) {
            const dx = t.clientX - joyRight.originX;
            const dy = t.clientY - joyRight.originY;
            const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
            const angle = Math.atan2(dy, dx);
            joyRight.x = Math.cos(angle) * (dist / 50);
            joyRight.y = Math.sin(angle) * (dist / 50);
            // Update virtual mouse immediately for responsiveness
            if (dist > 5) { // Deadzone
                const aimDist = 400; // Look ahead distance
                vMouse.x = player.pos.x + joyRight.x * aimDist;
                vMouse.y = player.pos.y + joyRight.y * aimDist;
            }
            updateJoyVisual('right', Math.cos(angle)*dist, Math.sin(angle)*dist);
        }
    }
}, {passive: false});

document.addEventListener('touchend', e => {
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === joyLeft.id) {
            joyLeft.active = false;
            joyLeft.x = 0; joyLeft.y = 0;
            updateJoyVisual('left', 0, 0);
        }
        if (t.identifier === joyRight.id) {
            joyRight.active = false;
            joyRight.x = 0; joyRight.y = 0;
            updateJoyVisual('right', 0, 0);
        }
    }
});

function updateJoyVisual(side, x, y) {
    const el = document.getElementById(`stick-${side}`);
    const zone = document.getElementById(`stick-${side}-zone`);
    if (side === 'left') {
        if (joyLeft.active) {
            // Reposition base visually to where touch started? No, static base is better for muscle memory
            // Just move the stick
            el.style.transform = `translate(${x}px, ${y}px)`;
        } else {
            el.style.transform = `translate(0px, 0px)`;
        }
    } else {
        // Right stick is invisible/visual helper
        // We move the stick relative to the static base in HTML
        el.style.transform = `translate(${x}px, ${y}px)`;
    }
}

/* ================================
   GAME CLASSES
   ================================ */
class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x*this.x + this.y*this.y); }
    normalize() {
        const m = this.mag();
        return m === 0 ? new Vector(0,0) : new Vector(this.x/m, this.y/m);
    }
}

class Entity {
    constructor(x, y, r, c) { this.pos = new Vector(x,y); this.r = r; this.c = c; this.dead = false; }
    draw(ctx) { ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.r, 0, Math.PI*2); ctx.fillStyle = this.c; ctx.fill(); }
}

class Player extends Entity {
    constructor() {
        super(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, 20, '#00bfff');
        this.hp = MAX_HP; this.stamina = MAX_STAMINA; this.divinity = MAX_DIVINITY; this.ap = 0;
        this.cooldowns = { q:0, e:0, r:0, daily:0 };
        this.maxCd = { q: SKILL_STATS.DAUNTING_LIGHT.cd, e: SKILL_STATS.SUNBURST.cd, r: SKILL_STATS.BASTION.cd, daily: SKILL_STATS.DAILY.cd };
        this.isDodging = false; this.dodgeTimer = 0;
        this.isCasting = false; this.castTimer = 0; this.castCb = null;
        this.slowTimer = 0; this.poisonTimer = 0; this.hotTimer = 0;
        this.exhausted = false;
    }
    update() {
        // Regen
        if (!this.isDodging) this.stamina = Math.min(MAX_STAMINA, this.stamina + STAMINA_REGEN);
        if (keys.tab) this.divinity = Math.min(MAX_DIVINITY, this.divinity + DIVINITY_REGEN_CHANNEL);
        else this.divinity = Math.min(MAX_DIVINITY, this.divinity + DIVINITY_REGEN_PASSIVE);

        // Status
        if (this.slowTimer > 0) this.slowTimer--;
        if (this.poisonTimer > 0) {
            if (this.poisonTimer % 60 === 0) { this.hp -= 50; showFloat("Poison!", this.pos, '#8f0'); }
            this.poisonTimer--;
        }
        if (this.hotTimer > 0) {
            if (this.hotTimer % 60 === 0) { this.hp = Math.min(MAX_HP, this.hp + SKILL_STATS.DAILY.hot); showFloat("+100", this.pos, '#0f0'); }
            this.hotTimer--;
        }

        // Exhaustion
        if (this.stamina <= 0 && !this.exhausted) { this.exhausted = true; showFloat("TIRED", this.pos, 'red'); }
        if (this.exhausted && this.stamina > 90) this.exhausted = false;

        // Cooldowns
        for(let k in this.cooldowns) if(this.cooldowns[k]>0) this.cooldowns[k]--;

        // Casting
        if (this.isCasting) {
            this.castTimer--;
            if (this.castTimer <= 0) { if (this.castCb) this.castCb(); this.isCasting = false; }
            return; // No move while casting
        }

        // Movement
        let speed = PLAYER_SPEED;
        if (this.exhausted || this.slowTimer > 0) speed *= 0.5;
        if (keys.rmb) speed *= SKILL_STATS.LANCE_OF_FAITH.slow;

        if (this.isDodging) {
            this.dodgeTimer--;
            if(this.dodgeTimer<=0) this.isDodging = false;
            this.pos = this.pos.add(this.dodgeDir.mult(12)); // Dash speed
        } else if (!keys.tab) {
            // Joystick Move
            if (Math.abs(joyLeft.x) > 0.1 || Math.abs(joyLeft.y) > 0.1) {
                this.pos.x += joyLeft.x * speed;
                this.pos.y += joyLeft.y * speed;
            }
        }

        // Bounds
        this.pos.x = Math.max(20, Math.min(CANVAS_WIDTH-20, this.pos.x));
        this.pos.y = Math.max(20, Math.min(CANVAS_HEIGHT-20, this.pos.y));
        
        // Auto-update vMouse if joystick is idle to stick to player? No, keep last aim position.
        if (joyRight.active) {
            // Handled in touchmove
        } else {
             // Keep vMouse relative to player based on last aim direction? 
             // Simplification: vMouse stays where it is.
        }
    }

    dodge() {
        if (this.stamina < 20 || this.isDodging || keys.tab || this.exhausted) return;
        if (this.isCasting) { this.isCasting = false; showFloat("Canceled", this.pos, '#fff'); }
        this.stamina -= 20;
        this.isDodging = true;
        this.dodgeTimer = 12;
        // Dodge in movement direction, or backward if aiming
        if (Math.abs(joyLeft.x) > 0.1 || Math.abs(joyLeft.y) > 0.1) {
            this.dodgeDir = new Vector(joyLeft.x, joyLeft.y).normalize();
        } else {
            // Dodge away from aim
            let aimDir = vMouse.sub(this.pos).normalize();
            this.dodgeDir = aimDir.mult(-1);
        }
    }
}

/* ================================
   GLOBALS & LOGIC
   ================================ */
let player;
let enemies = [];
let projectiles = [];
let splats = [];
let floats = [];
let frame = 0;
let gameActive = false;
let score = 0;
let kills = 0;

function startGame() {
    document.getElementById('menu-overlay').style.display = 'none';
    player = new Player();
    enemies = [];
    projectiles = [];
    splats = [];
    floats = [];
    frame = 0;
    score = 0;
    kills = 0;
    gameActive = true;
    loop();
}

function spawnMob() {
    let type = Math.random() < 0.6 ? 'MELEE' : (Math.random() < 0.5 ? 'RANGED' : 'HEALER');
    let x, y, d;
    do {
        x = Math.random() * CANVAS_WIDTH;
        y = Math.random() * CANVAS_HEIGHT;
        d = new Vector(x,y).sub(new Vector(NODE_CENTER_X, NODE_CENTER_Y)).mag();
    } while(d < NODE_RADIUS + 50);
    
    enemies.push({
        pos: new Vector(x,y),
        type: type,
        hp: type==='MELEE'?8000:(type==='RANGED'?3000:5000),
        maxHp: type==='MELEE'?8000:(type==='RANGED'?3000:5000),
        r: 20,
        color: type==='MELEE'?'#f40':(type==='RANGED'?'#36f':'#0c0'),
        speed: type==='MELEE'?2:(type==='RANGED'?4:3),
        actTimer: 0
    });
}

function showFloat(txt, pos, col) {
    floats.push({txt:txt, pos:new Vector(pos.x, pos.y), col:col, life:60});
}

/* ================================
   SKILLS
   ================================ */
function castSkills() {
    if (player.isCasting || player.isDodging || keys.tab) return;

    // Dodge
    if (keys.shift) player.dodge();

    // Sacred Flame (LMB or Auto)
    if ((keys.lmb || (autoFire && joyRight.active)) && frame % SKILL_STATS.SACRED_FLAME.frames === 0) {
        let dir = vMouse.sub(player.pos);
        projectiles.push({
            pos: new Vector(player.pos.x, player.pos.y),
            vel: dir.normalize().mult(SKILL_STATS.SACRED_FLAME.speed),
            dmg: SKILL_STATS.SACRED_FLAME.damage,
            owner: 'player',
            life: 60,
            r: 8,
            col: SKILL_STATS.SACRED_FLAME.color,
            isSF: true
        });
        player.ap = Math.min(MAX_AP, player.ap + 5);
    }

    // Lance (RMB)
    if (keys.rmb && frame % SKILL_STATS.LANCE_OF_FAITH.tick === 0) {
        let aimDir = vMouse.sub(player.pos);
        let hit = false;
        enemies.forEach(e => {
            let toE = e.pos.sub(player.pos);
            let angle = Math.abs(Math.atan2(aimDir.y, aimDir.x) - Math.atan2(toE.y, toE.x));
            if (toE.mag() < SKILL_STATS.LANCE_OF_FAITH.range && angle < 0.3) {
                e.hp -= SKILL_STATS.LANCE_OF_FAITH.damage;
                showFloat(SKILL_STATS.LANCE_OF_FAITH.damage, e.pos, '#ff0');
                if(e.hp<=0) kill(e);
                hit = true;
            }
        });
        if(hit) player.ap = Math.min(MAX_AP, player.ap + 10);
    }

    // Q: Daunting Light
    if (keys.q && player.cooldowns.q <= 0 && player.divinity >= SKILL_STATS.DAUNTING_LIGHT.div) {
        player.divinity -= SKILL_STATS.DAUNTING_LIGHT.div;
        player.cooldowns.q = player.maxCd.q;
        player.isCasting = true;
        player.castTimer = SKILL_STATS.DAUNTING_LIGHT.cast;
        let tPos = new Vector(vMouse.x, vMouse.y); // Capture aim location
        player.castCb = () => {
            splats.push({pos:tPos, r:SKILL_STATS.DAUNTING_LIGHT.radius, col:'gold', life:15});
            enemies.forEach(e => {
                if(e.pos.sub(tPos).mag() < SKILL_STATS.DAUNTING_LIGHT.radius) {
                    e.hp -= SKILL_STATS.DAUNTING_LIGHT.damage;
                    showFloat(SKILL_STATS.DAUNTING_LIGHT.damage+"!", e.pos, '#ff0');
                    if(e.hp<=0) kill(e);
                    player.ap = Math.min(MAX_AP, player.ap + 30);
                }
            });
        };
    }

    // E: Sunburst
    if (keys.e && player.cooldowns.e <= 0) {
        player.cooldowns.e = player.maxCd.e;
        player.hp = Math.min(MAX_HP, player.hp + SKILL_STATS.SUNBURST.heal);
        splats.push({pos:player.pos, r:SKILL_STATS.SUNBURST.radius, col:'orange', life:10});
        enemies.forEach(e => {
            let dist = e.pos.sub(player.pos);
            if(dist.mag() < SKILL_STATS.SUNBURST.radius) {
                e.hp -= SKILL_STATS.SUNBURST.damage;
                // Knockback
                e.pos = e.pos.add(dist.normalize().mult(SKILL_STATS.SUNBURST.knock));
                if(e.hp<=0) kill(e);
            }
        });
    }

    // R: Bastion
    if (keys.r && player.cooldowns.r <= 0 && player.divinity >= SKILL_STATS.BASTION.div) {
        player.divinity -= SKILL_STATS.BASTION.div;
        player.cooldowns.r = player.maxCd.r;
        player.isCasting = true;
        player.castTimer = SKILL_STATS.BASTION.cast;
        let tPos = new Vector(vMouse.x, vMouse.y);
        player.castCb = () => {
            splats.push({pos:tPos, r:SKILL_STATS.BASTION.radius, col:'#0f0', life:10});
            if(player.pos.sub(tPos).mag() < SKILL_STATS.BASTION.radius) {
                player.hp = Math.min(MAX_HP, player.hp + SKILL_STATS.BASTION.heal);
                showFloat("+" + SKILL_STATS.BASTION.heal, player.pos, '#0f0');
            }
        };
    }
    
    // 1: Daily
    if (keys['1'] && player.cooldowns.daily <= 0 && player.ap >= MAX_AP) {
        player.ap = 0;
        player.cooldowns.daily = player.maxCd.daily;
        player.hotTimer = SKILL_STATS.DAILY.hotDur;
        let tPos = new Vector(vMouse.x, vMouse.y);
        splats.push({pos:tPos, r:SKILL_STATS.DAILY.radius, col:'white', life:90}); // Animation
        setTimeout(() => {
             enemies.forEach(e => {
                if(e.pos.sub(tPos).mag() < SKILL_STATS.DAILY.radius) {
                    e.hp -= SKILL_STATS.DAILY.damage;
                    e.stun = SKILL_STATS.DAILY.stun;
                    if(e.hp<=0) kill(e);
                }
            });
        }, 1000); // Delayed hit
    }
}

function kill(e) {
    if(e.dead) return;
    e.dead = true;
    kills++;
    player.ap = Math.min(MAX_AP, player.ap + 50);
}

/* ================================
   MAIN LOOP
   ================================ */
function loop() {
    if(!gameActive) return;
    frame++;
    
    // Spawn
    if (frame % 240 === 0 && enemies.length < 8) spawnMob();

    player.update();
    castSkills();

    // Enemies
    enemies.forEach(e => {
        if(e.dead) return;
        if(e.stun && e.stun > 0) { e.stun--; return; }
        
        // Move
        let toP = player.pos.sub(e.pos);
        if (toP.mag() > 30) e.pos = e.pos.add(toP.normalize().mult(e.speed));
        
        // Attack
        if (toP.mag() < 40 && frame % 60 === 0) {
            player.hp -= 50;
            showFloat("-50", player.pos, 'red');
        }
        // Ranged attacks logic simplified for mobile perf
        if (e.type !== 'MELEE' && frame % 120 === 0 && toP.mag() < 500) {
            projectiles.push({
                pos: new Vector(e.pos.x, e.pos.y),
                vel: toP.normalize().mult(6),
                dmg: 100, owner: 'enemy', life: 100, r: 6, col: '#f0f'
            });
        }
    });

    // Projectiles
    projectiles.forEach(p => {
        p.pos = p.pos.add(p.vel);
        p.life--;
        if(p.owner === 'player') {
            enemies.forEach(e => {
                if(!e.dead && e.pos.sub(p.pos).mag() < e.r + p.r) {
                    e.hp -= p.dmg;
                    p.life = 0;
                    showFloat(p.dmg, e.pos, '#ff0');
                    if(e.hp<=0) kill(e);
                }
            });
        } else {
            if(player.pos.sub(p.pos).mag() < 20 + p.r) {
                player.hp -= p.dmg;
                p.life = 0;
                showFloat("-"+p.dmg, player.pos, 'red');
            }
        }
    });

    // Cleanup
    projectiles = projectiles.filter(p => p.life > 0);
    enemies = enemies.filter(e => !e.dead);
    splats = splats.filter(s => s.life-- > 0);
    floats = floats.filter(f => {
        f.pos.y -= 1;
        return f.life-- > 0;
    });

    // Node Logic
    let onNode = player.pos.sub(new Vector(NODE_CENTER_X, NODE_CENTER_Y)).mag() < NODE_RADIUS;
    if (onNode) score += 1; // Simple score increment
    
    if (player.hp <= 0) gameOver("DIED");
    if (frame >= GAME_END_FRAME) gameOver("VICTORY");

    draw();
    updateUI();
    requestAnimationFrame(loop);
}

function gameOver(msg) {
    gameActive = false;
    document.getElementById('menu-overlay').style.display = 'flex';
    document.getElementById('menu-title').innerText = msg;
    document.getElementById('menu-msg').innerText = `Score: ${score} | Kills: ${kills}`;
}

function updateUI() {
    document.getElementById('hp-bar').querySelector('div').style.width = (player.hp/MAX_HP*100)+'%';
    document.getElementById('hp-val').innerText = Math.ceil(player.hp);
    document.getElementById('ap-bar').querySelector('div').style.width = (player.ap/MAX_AP*100)+'%';
    document.getElementById('stam-bar').querySelector('div').style.width = (player.stamina/MAX_STAMINA*100)+'%';
    document.getElementById('div-bar').querySelector('div').style.width = (player.divinity/MAX_DIVINITY*100)+'%';
    document.getElementById('game-timer').innerText = (frame/60).toFixed(1)+'s';
    document.getElementById('game-score').innerText = score;
    
    // Cooldowns overlays
    const setCD = (id, cur, max) => {
        const el = document.getElementById(id);
        if(cur > 0) { el.style.display = 'flex'; el.innerText = (cur/60).toFixed(1); }
        else { el.style.display = 'none'; }
    };
    setCD('cd-q', player.cooldowns.q, player.maxCd.q);
    setCD('cd-e', player.cooldowns.e, player.maxCd.e);
    setCD('cd-r', player.cooldowns.r, player.maxCd.r);
    setCD('cd-daily', player.cooldowns.daily, player.maxCd.daily);
    
    // Highlight active inputs
    document.getElementById('btn-tab').style.borderColor = keys.tab ? 'white' : '#555';
}

function draw() {
    ctx.fillStyle = '#111'; ctx.fillRect(0,0,CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Node
    ctx.beginPath();
    ctx.arc(NODE_CENTER_X, NODE_CENTER_Y, NODE_RADIUS, 0, Math.PI*2);
    ctx.strokeStyle = '#333'; ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle = 'rgba(0,255,100,0.05)'; ctx.fill();

    // Splats
    splats.forEach(s => {
        ctx.beginPath(); ctx.arc(s.pos.x, s.pos.y, s.r, 0, Math.PI*2);
        ctx.fillStyle = s.col; ctx.globalAlpha = 0.4; ctx.fill(); ctx.globalAlpha = 1;
    });

    // Enemies
    enemies.forEach(e => {
        e.draw(ctx);
        // HP bar
        ctx.fillStyle = 'red'; ctx.fillRect(e.pos.x-15, e.pos.y-30, 30*(e.hp/e.maxHp), 4);
    });

    // Player
    player.draw(ctx);
    if(keys.tab) {
        ctx.strokeStyle = '#00bfff'; ctx.beginPath(); ctx.arc(player.pos.x, player.pos.y, 30, 0, Math.PI*2); ctx.stroke();
    }
    
    // Projectiles
    projectiles.forEach(p => {
        ctx.beginPath(); ctx.arc(p.pos.x, p.pos.y, p.r, 0, Math.PI*2);
        ctx.fillStyle = p.col; ctx.fill();
    });

    // Targeting Reticle (Virtual Mouse)
    if(joyRight.active || keys.q || keys.r) {
        ctx.beginPath();
        ctx.arc(vMouse.x, vMouse.y, 10, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Line from player to reticle
        ctx.beginPath();
        ctx.moveTo(player.pos.x, player.pos.y);
        ctx.lineTo(vMouse.x, vMouse.y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    
    // Beam visual
    if (keys.rmb) {
        ctx.beginPath(); ctx.moveTo(player.pos.x, player.pos.y); ctx.lineTo(vMouse.x, vMouse.y);
        ctx.strokeStyle = 'gold'; ctx.lineWidth = 4; ctx.stroke();
    }

    // Floats
    floats.forEach(f => {
        ctx.fillStyle = f.col; ctx.font = "bold 16px Arial"; ctx.fillText(f.txt, f.pos.x, f.pos.y);
    });
}
</script>
</body>
</html>